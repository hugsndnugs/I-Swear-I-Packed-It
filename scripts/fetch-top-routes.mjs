#!/usr/bin/env node
/**
 * Fetches the top N profitable cargo routes from UEX Corp API and writes
 * data/top-100-routes.json and src/data/routes.generated.ts.
 * - When UEX_API_TOKEN is set: fetches routes per commodity, dedupes by code, sorts by profit, takes top N.
 * - Fallback: If token is unset or API fails, uses existing data/top-100-routes.json if present and
 *   regenerates routes.generated.ts; otherwise exits with an error.
 * - PREFLIGHT_TOP_ROUTES_SKIP_API=1: skip API and only regenerate routes.generated.ts from existing JSON.
 *
 * Run: node scripts/fetch-top-routes.mjs
 * Env:  UEX_API_TOKEN=<token>                      (create app at uexcorp.space/api/apps)
 *       PREFLIGHT_TOP_ROUTES_COMMODITIES=60        (number of commodities to query; default 60)
 *       PREFLIGHT_TOP_ROUTES_LIMIT=100             (top N routes; default 100)
 *       PREFLIGHT_TOP_ROUTES_OUTPUT=<path>         (JSON output path; default data/top-100-routes.json)
 *       PREFLIGHT_TOP_ROUTES_SKIP_API=1            (skip API, regenerate from existing JSON only)
 *       UEX_CLIENT_VERSION=<version>               (optional; set if your UEX app has Client Version Lock)
 */
import { writeFileSync, readFileSync, existsSync } from 'fs'
import { fileURLToPath } from 'url'
import { dirname, join } from 'path'

const __dirname = dirname(fileURLToPath(import.meta.url))
const ROOT = join(__dirname, '..')
const DEFAULT_JSON_PATH = join(ROOT, 'data', 'top-100-routes.json')
const OUT_PATH = join(ROOT, 'src', 'data', 'routes.generated.ts')

const UEX_BASE = 'https://api.uexcorp.uk/2.0'
const DELAY_MS = 2000

const COMMODITIES = Number(process.env.PREFLIGHT_TOP_ROUTES_COMMODITIES) || 60
const LIMIT = Number(process.env.PREFLIGHT_TOP_ROUTES_LIMIT) || 100
const JSON_PATH = process.env.PREFLIGHT_TOP_ROUTES_OUTPUT || DEFAULT_JSON_PATH
const SKIP_API = process.env.PREFLIGHT_TOP_ROUTES_SKIP_API === '1' || process.env.PREFLIGHT_TOP_ROUTES_SKIP_API === 'true'

function sleep(ms) {
  return new Promise((r) => setTimeout(r, ms))
}

function slugify(s) {
  if (!s || typeof s !== 'string') return 'unknown'
  return s
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '')
}

function mapUexRoute(r) {
  const origin = r.origin_terminal_name || r.origin_terminal_slug || 'Unknown'
  const dest = r.destination_terminal_name || r.destination_terminal_slug || 'Unknown'
  const originSlug = r.origin_terminal_slug || slugify(origin)
  const destSlug = r.destination_terminal_slug || slugify(dest)
  const id = `${originSlug}-${destSlug}`.replace(/--+/g, '-')
  const label = `${origin} – ${dest}`
  const distance = r.distance != null ? Number(r.distance) : 0
  const crossSystem =
    r.id_star_system_origin != null &&
    r.id_star_system_destination != null &&
    r.id_star_system_origin !== r.id_star_system_destination
  const longHaul = crossSystem || distance > 50
  const highValueCommodities = ['laranite', 'quantanium', 'agricium', 'gold', 'titanium']
  const commoditySlug = (r.commodity_slug || r.commodity_name || '').toLowerCase()
  const highValue = highValueCommodities.some((c) => commoditySlug.includes(c))
  return {
    id,
    label,
    ...(longHaul && { longHaul: true }),
    ...(highValue && { highValue: true }),
  }
}

async function uexFetch(path, token) {
  await sleep(DELAY_MS)
  const url = `${UEX_BASE}${path}`
  const headers = {
    Authorization: `Bearer ${token}`,
    Accept: 'application/json',
  }
  const clientVersion = process.env.UEX_CLIENT_VERSION
  if (clientVersion) headers['X-Client-Version'] = clientVersion

  const res = await fetch(url, { headers })
  const body = await res.json().catch(() => ({}))
  if (res.status === 429) {
    const retryAfter = Math.min(
      120000,
      Math.max(60000, (Number(res.headers.get('Retry-After')) || 60) * 1000)
    )
    console.warn(`Rate limited (429). Waiting ${retryAfter / 1000}s...`)
    await sleep(retryAfter)
    return uexFetch(path, token)
  }
  if (!res.ok) {
    const msg = body.message || body.status || res.statusText
    throw new Error(`UEX API ${res.status}: ${msg} (${url})`)
  }
  return body
}

function loadFallbackJson() {
  if (!existsSync(JSON_PATH)) return null
  try {
    const raw = readFileSync(JSON_PATH, 'utf8')
    const parsed = JSON.parse(raw)
    if (!Array.isArray(parsed)) return null
    return parsed.filter(
      (r) => r && typeof r === 'object' && typeof r.id === 'string' && typeof r.label === 'string'
    )
  } catch {
    return null
  }
}

function writeGenerated(routes) {
  const lines = [
    '// Generated by scripts/fetch-top-routes.mjs – do not edit by hand',
    '',
    `export const BEST_ROUTES = ${JSON.stringify(routes, null, 2)} as const`,
    '',
  ]
  writeFileSync(OUT_PATH, lines.join('\n'), 'utf8')
  console.log(`Wrote ${routes.length} routes to ${OUT_PATH}`)
}

function writeJson(routes) {
  writeFileSync(JSON_PATH, JSON.stringify(routes, null, 2), 'utf8')
  console.log(`Wrote ${routes.length} routes to ${JSON_PATH}`)
}

function useFallback() {
  const routes = loadFallbackJson()
  if (routes == null || routes.length === 0) {
    console.error(
      'No UEX_API_TOKEN set (or API failed) and no existing data/top-100-routes.json found. ' +
        'Run with UEX_API_TOKEN set once to generate the file, or create data/top-100-routes.json manually.'
    )
    process.exit(1)
  }
  console.warn('Using fallback: existing data/top-100-routes.json')
  writeGenerated(routes)
}

async function fetchFromUex(token) {
  const commoditiesRes = await uexFetch('/commodities/', token)
  const commodities = commoditiesRes?.data ?? commoditiesRes
  const list = Array.isArray(commodities) ? commodities : []
  const ids = list.slice(0, COMMODITIES).map((c) => c.id).filter((id) => id != null)
  if (ids.length === 0) {
    throw new Error('No commodities returned from UEX API')
  }

  const allRaw = []
  const seenCodes = new Set()

  for (const id of ids) {
    const routesRes = await uexFetch(`/commodities_routes/?id_commodity=${id}`, token)
    const routes = routesRes?.data ?? routesRes
    const arr = Array.isArray(routes) ? routes : []
    for (const r of arr) {
      const code = r.code ?? `${r.origin_terminal_slug ?? r.origin_terminal_name}-${r.destination_terminal_slug ?? r.destination_terminal_name}-${r.commodity_slug ?? r.id_commodity}`
      if (seenCodes.has(code)) continue
      seenCodes.add(code)
      allRaw.push(r)
    }
  }

  allRaw.sort((a, b) => (b.profit ?? 0) - (a.profit ?? 0))
  const top = allRaw.slice(0, LIMIT)
  return top.map(mapUexRoute)
}

async function main() {
  if (SKIP_API) {
    const routes = loadFallbackJson()
    if (routes == null || routes.length === 0) {
      console.error(`PREFLIGHT_TOP_ROUTES_SKIP_API=1 but no valid data at ${JSON_PATH}`)
      process.exit(1)
    }
    writeGenerated(routes)
    return
  }

  const token = process.env.UEX_API_TOKEN
  if (!token) {
    useFallback()
    return
  }

  try {
    const routes = await fetchFromUex(token)
    writeJson(routes)
    writeGenerated(routes)
  } catch (err) {
    console.error('UEX API failed:', err.message)
    useFallback()
  }
}

main().catch((err) => {
  console.error(err)
  process.exit(1)
})
